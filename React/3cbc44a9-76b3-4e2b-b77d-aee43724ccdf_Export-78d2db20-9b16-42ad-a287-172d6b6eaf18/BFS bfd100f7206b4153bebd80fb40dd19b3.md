# BFS

BFS 는 breadth-first-search 의 약자로 우리말로 ‘너비 우선 탐색’이라고 불리는 알고리즘. 그래프 탐색 알고리즘의 한 종류로 모든 컴포넌트의 정점을 한 번씩 순회하는 용도. BFS 는 탐색을 할 때 각 정점의 최단거리를 계산하는 데에 유용하게 쓰임.

![Untitled](BFS%20bfd100f7206b4153bebd80fb40dd19b3/Untitled.png)

가장 처음에 0번 노드 부터 방문을 시작한다.

![Untitled](BFS%20bfd100f7206b4153bebd80fb40dd19b3/Untitled%201.png)

0번 노드와 인접한 노드들을 모두 방문한다.

![Untitled](BFS%20bfd100f7206b4153bebd80fb40dd19b3/Untitled%202.png)

이전 단계에서 방문한 1,2번 노드와 인접한 노드들을 모두 방문한다.

![Untitled](BFS%20bfd100f7206b4153bebd80fb40dd19b3/Untitled%203.png)

마지막으로 4, 7번 노드를 방문한다.

각 단계의 정점들은 그 안에서 방문 순서가 바뀔 수는 있지만 다른 단계와는 방문 순서가 섞이지 않는다. 0번 노드를 방문한 경우를 0단계 그 다음의 경우를 차례로 1, 2, 3단계라고 했을 때 k단계에 방문하는 정점들은 시작점으로부터의 최단 거리가 k이다.

![Untitled](BFS%20bfd100f7206b4153bebd80fb40dd19b3/Untitled%204.png)

BFS 는 다음과 같이 시작점에서 퍼져 나가는 형태로 탐색을 진행한다고 생각할 수 있다.

BFS 탐색 코드 예시

```cpp
#include <bits/stdc++.h>
using namespace std;
#define X first
#define Y second
int board[502][502] =
    {{1, 1, 1, 0, 1, 0, 0, 0, 0, 0},
     {1, 0, 0, 0, 1, 0, 0, 0, 0, 0},
     {1, 1, 1, 0, 1, 0, 0, 0, 0, 0},
     {1, 1, 0, 0, 1, 0, 0, 0, 0, 0},
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};  // 1이 파란 칸, 0이 빨간 칸에 대응
bool vis[502][502];                    // 해당 칸의 방문 여부 저장 처음에는 전부 0
int n = 7, m = 10;                     // board의 행과 열의 크기
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};  // 상하좌우 네 방향을 나타네는 방향벡터(x가 행, y가 열을 나타냄)

int main(void) {
  ios::sync_with_stdio(0);
  cin.tie(0);
  queue<pair<int, int> > Q;
  vis[0][0] = 1;  // (0, 0) 시작점부터 방문 시작
  Q.push({0, 0});
  while (!Q.empty()) {  // Q가 비어있으면 더 이상 탐색 못함
    pair<int, int> cur = Q.front();
    Q.pop();
    cout << "(" << cur.X << ", " << cur.Y << ") -> ";
    for (int dir = 0; dir < 4; dir++) {  // 상하좌우 칸 탐색
      int nx = cur.X + dx[dir];
      int ny = cur.Y + dy[dir];                              // nx, ny에 다음 탐색할 좌표 넣어줌
      if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;  // board의 범위를 벗어나는 경우엔 넘어감
      if (vis[nx][ny] || board[nx][ny] != 1) continue;       // 이미 방문했던 칸이거나, 빨강 칸이면(갈 수 없는 칸이면) 넘어감
      vis[nx][ny] = 1;
      Q.push({nx, ny});
    }
  }
}
```